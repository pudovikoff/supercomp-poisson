# Отчет по решению задачи Пуассона методом фиктивных областей

## Вариант 7: Область-сапожок

**Автор:** Пудовиков А.Д.  
**Курс:** Суперкомпьютерное моделирование и технологии

---

## 1. Постановка задачи

### 1.1 Математическая формулировка

Требуется решить двумерную задачу Дирихле для уравнения Пуассона:

```
-Δu = f(x, y),  (x, y) ∈ D
u(x, y) = 0,    (x, y) ∈ γ
```

где:
- **Оператор Лапласа:**  
  $$\Delta u = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}$$

- **Правая часть:**  
  $$f(x, y) = 1 \quad \forall (x, y) \in D$$

- **Область D (сапожок):**  
  $$D = \{(x,y): -1 < x, y < 1\} \setminus \{(x,y): 0 \leq x, y < 1\}$$

  Это квадрат $[-1, 1] \times [-1, 1]$ с вырезанным правым верхним квадрантом $[0, 1] \times [0, 1]$.

- **Граница γ:**  
  $$\gamma = \partial D$$

### 1.2 Геометрия области

![Область-сапожок](results/plot_d.png)

**Свойства области:**
- Площадь: $S_D = 3$ (квадрат 2×2 минус квадрат 1×1)
- Граница кусочно-гладкая с угловой точкой в (0, 0)

---

## 2. Метод решения

### 2.1 Метод фиктивных областей

Криволинейная область $D$ заменяется прямоугольником:

$$\Pi = \{(x, y) : -1 < x < 1, -1 < y < 1\}$$

с введением кусочно-постоянного коэффициента:

$$k(x, y) = \begin{cases}
1, & (x, y) \in D \\
1/\varepsilon, & (x, y) \in \hat{D}
\end{cases}$$

где $\hat{D} = \Pi \setminus D$ — фиктивная область, $\varepsilon = h^2$ — параметр метода ($h$ — максимальный шаг сетки).

Решается вспомогательная задача:

$$-\frac{\partial}{\partial x}\left(k(x,y)\frac{\partial v}{\partial x}\right) - \frac{\partial}{\partial y}\left(k(x,y)\frac{\partial v}{\partial y}\right) = F(x, y)$$

$$v(x, y) = 0, \quad (x, y) \in \Gamma$$

где:

$$F(x, y) = \begin{cases}
f(x, y) = 1, & (x, y) \in D \\
0, & (x, y) \in \hat{D}
\end{cases}$$

**Теорема (приближение):**  
$$\max_{(x,y) \in D} |v(x, y) - u(x, y)| < C\varepsilon$$

### 2.2 Разностная схема

На равномерной прямоугольной сетке $\bar{\omega}_h = \bar{\omega}_1 \times \bar{\omega}_2$:

$$\bar{\omega}_1 = \{x_i = -1 + ih_1, \, i = 0, \overline{M}\}, \quad h_1 = \frac{2}{M}$$
$$\bar{\omega}_2 = \{y_j = -1 + jh_2, \, j = 0, \overline{N}\}, \quad h_2 = \frac{2}{N}$$

Дифференциальное уравнение аппроксимируется разностным:

$$-\frac{1}{h_1}\left(a_{i+1,j}\frac{w_{i+1,j} - w_{i,j}}{h_1} - a_{i,j}\frac{w_{i,j} - w_{i-1,j}}{h_1}\right) - \frac{1}{h_2}\left(b_{i,j+1}\frac{w_{i,j+1} - w_{i,j}}{h_2} - b_{i,j}\frac{w_{i,j} - w_{i,j-1}}{h_2}\right) = F_{i,j}$$

для $i = 1, \overline{M-1}$, $j = 1, \overline{N-1}$.

**Коэффициенты:**

$$a_{i,j} = \frac{1}{h_2}\int_{y_{j-1/2}}^{y_{j+1/2}} k(x_{i-1/2}, t) \, dt$$

$$b_{i,j} = \frac{1}{h_1}\int_{x_{i-1/2}}^{x_{i+1/2}} k(t, y_{j-1/2}) \, dt$$

**Правая часть:**

$$F_{i,j} = \frac{1}{h_1 h_2}\iint_{\Pi_{i,j}} F(x, y) \, dx \, dy$$

где $\Pi_{i,j}$ — ячейка сетки вокруг узла $(x_i, y_j)$.

**Граничные условия:**

$$w_{i,j} = 0, \quad (x_i, y_j) \in \Gamma$$

### 2.3 Метод сопряженных градиентов с предобуславливанием

Разностная схема приводится к системе линейных алгебраических уравнений:

$$Aw = B$$

где $A : H \to H$ — самосопряженный положительно определенный оператор.

**Скалярное произведение и норма:**

$$(u, v) = \sum_{i=1}^{M-1}\sum_{j=1}^{N-1} h_1 h_2 \, u_{i,j} v_{i,j}$$

$$\|u\|_E = \sqrt{(u, u)}$$

**Диагональный предобуславливатель:**

$$(Dw)_{i,j} = \left[\frac{a_{i+1,j} + a_{i,j}}{h_1^2} + \frac{b_{i,j+1} + b_{i,j}}{h_2^2}\right] w_{i,j}$$

**Алгоритм:**

1. Начальное приближение: $w^{(0)} = 0$
2. Невязка: $r^{(0)} = B - Aw^{(0)} = B$
3. Решение: $Dz^{(0)} = r^{(0)}$
4. Направление спуска: $p^{(1)} = z^{(0)}$

Для $k = 0, 1, 2, \ldots$ до сходимости:

5. $Ap^{(k+1)}$ — применение оператора
6. $\alpha_{k+1} = \frac{(z^{(k)}, r^{(k)})}{(Ap^{(k+1)}, p^{(k+1)})}$
7. $w^{(k+1)} = w^{(k)} + \alpha_{k+1} p^{(k+1)}$
8. **Проверка сходимости:** если $\|w^{(k+1)} - w^{(k)}\|_E < \delta$, то STOP
9. $r^{(k+1)} = r^{(k)} - \alpha_{k+1} Ap^{(k+1)}$
10. $Dz^{(k+1)} = r^{(k+1)}$
11. $\beta_{k+1} = \frac{(z^{(k+1)}, r^{(k+1)})}{(z^{(k)}, r^{(k)})}$
12. $p^{(k+1)} = z^{(k+1)} + \beta_{k+1} p^{(k)}$

**Контроль монотонности:**

Функционал $H(w^{(k)}) = (B + r^{(k)}, w^{(k)})$ должен монотонно возрастать. При нарушении монотонности — перезапуск метода.

---

## 3. Структура программы

```cpp
// 1. Геометрические функции
bool is_in_domain(double x, double y)
double segment_length_in_D(...)
double cell_area_in_D(...)

// 2. Класс PoissonSolver
class PoissonSolver {
    void compute_coefficients()   // Вычисление a, b, F
    void apply_A(...)              // Оператор A
    void apply_D_inv(...)          // Предобуславливатель D^{-1}
    void solve_CG(...)             // Метод сопряженных градиентов
    double dot_product(...)        // Скалярное произведение
    double euclidean_norm(...)     // Евклидова норма
    double max_norm(...)           // Максимум норма
    void save_solution(...)        // Сохранение результата
}
```


---

## 4. Результаты запусков последовательной программы

### 4.1 Численные результаты для последовательного метода

| Сетка $M \times N$ | Узлов | Итераций | Время (с) | $\\|w\\|_E$ | $\\|w\\|_C$ |
|--------------------|-------|----------|-----------|-------------|-------------|
| 10 × 10            | 81    | 21       | 0.000020  | 1.497e-01   | 1.512e-01   |
| 20 × 20            | 361   | 40       | 0.000149  | 1.450e-01   | 1.492e-01   |
| 40 × 40            | 1521  | 73       | 0.001105  | 1.441e-01   | 1.491e-01   |

Результаты ожидаемые - узмельчение сетки привело к увеличению количества итераций и уменьшению ошибки.


#### Визуализация решения

**2D визуализация (цветная карта и изолинии):**

![2D визуализация решения](results/solution_2d.png)

**3D визуализация (поверхность с контурами):**

![3D визуализация решения](results/solution_3d.png)

Из визуализации видно:
- Решение положительно во всей области ($f = 1 > 0$)
- Максимум значения $u \approx 0.149$ достигается внутри области
- Значения плавно убывают к границе (граничное условие $u = 0$)
- Решение симметрично относительно диагонали $y = x$

### 4.2 Свойства решения

1. **Положительность:** $u(x, y) > 0$ для всех $(x, y) \in D$ (так как $f = 1 > 0$)
2. **Максимум:** достигается внутри области (принцип максимума для эллиптических уравнений)
3. **Симметрия:** решение примерно симметрично относительно диагонали $y = x$ (из-за геометрии области)
4. **Граничные значения:** $u \to 0$ при приближении к границе


## 5. Результаты запусков OpenMP программы

Основная модификация OpenMP версии от классической последовательной заключалось в использовани директив перед циклами.
Так как в программе в основном использовались двойные циклы для вычисления, приведу пример для них:

```cpp  
#pragma omp parallel for reduction(+:var) schedule(static) collapse(2)
```

Директива $for$, клауза $reduction (+:var)$ - для оператора $+$ сохраняем значения в $var$,
$schedule(static)$ - деление цикла на блоки равной длины, $collapse(2)$ - сворачивание двойных циклов.

### 5.1 Сравнение запусков на сетке 40 × 40 OpenMP 

| Тип Запуска               | Итераций | Время (с) | $\\|w\\|_E$ | $\\|w\\|_C$ |
|---------------------------|----------|-----------|-------------|-------------|
| 40 × 40 последовательный  | 73       | 0.001105  | 1.441e-01   | 1.491e-01   |
| 40 × 40 1 нить            | 73       | 0.0094    | 1.440562e-01   |  1.490863e-01  |
| 40 × 40 4 нити            | 73       | 0.003975  | 1.440562e-01   | 1.490863e-01   |     
| 40 × 40 16 нитей          | 73       | 0.003129  | 1.440562e-01   | 1.490863e-01   |  


Видим, что на такой небольшой решётке время запусков OpenMP решения больше.
Это может быть связано с тем, что  нам не надо было создавать новые нити и копировать часть данных. При этом ошибка решения сопоставимая.
На параллельных запусках - наблюдаем тенденцию уменьшения времени работы программы.   


### 5.2 Запуски на больших сетках и графики ускорения

Таблица 1: OpenMP версии

| Кол-во нитей | Число точек сетки (M×N) | Число итераций | Время, с | Ускорение, раз |
|---:|---:|---:|---:|---:|
| 1 | 400×600 | 533 | 10.59| - |
| 2 | 400×600 | 533 | 5.03 | 2.11|
| 4 | 400×600 | 533 | 2.54 | 4.17 |
| 8 | 400×600 | 533 | 2.08 | 5.09 |
| 16 | 400×600 | 533 | 1.07 | 9.90 |
| 1 | 800×1200 | 1048 | 79.06 | - |
| 4 | 800×1200 | 1048 | 20.03 | 3.95 |
| 8 | 800×1200 | 1048 | 16.56 | 4.78 |
| 16 | 800×1200 | 1048 | 5.13 | 15.41 |
| 32 | 800×1200 | 1048 | 4.26 | 18.56 |

#### Графики ускорения и времени выполнения

![Графики ускорения и времени выполнения OpenMP](results/speedup_graph_OpenMP.png)


Из графиков видно:
- **Ускорение** растет с увеличением числа нитей, достигая 18.56× на 32 нитях для сетки 800×1200
- Для сетки 800×1200 эффективность выше благодаря большему объему вычислений

## 6. Результаты запусков MPI программы

Для создания MPI версии программы было необходимо разработать алгоритм двумерного разбиения исходного прямоугольника, так чтобы:

1. Отношение количества узлов по переменым $x$ и $y$ в каждом домене принадлежало
диапазону [1/2,2]. 
Это требование выполняется с помощью выбора "самого квадратного" разбиения (у которого отношение сторон ближе всего к 1).
Перебор происходит только по тем разбиениям, которые удовлетворяют заявленному условию.

2. Количество узлов по переменым $x$ и $y$ любых двух доменов отличалось не более, чем
на единицу. Это требование автоматически выполняется при использовании блочного распределения узлов. 
Если всего $N_x$ внутренних узлов по $x$ распределяются на $P_x$ процессов, то каждый процесс получает либо $\lfloor N_x / P_x \rfloor$, либо $\lceil N_x / P_x \rceil$ узлов, то есть разница в один узел.

Далее надо было реализовать обмен граничными значениями  на решётке для процессов, для этого используется функция excahnge() с MPI_Sendrecv().
Для нахождения соседей по решётки использовал MPI_Cart_shift().
Для проверки условий остановки и вычисления норм используются операции MPI_Allreduce(), чтобы учесть значения со всех доменов.


### 6.1 Сравнение запусков на сетке 40 × 40 MPI 

| Тип Запуска               | Итераций | Время (с) | $\\|w\\|_E$ | $\\|w\\|_C$ |
|---------------------------|----------|-----------|-------------|-------------|
| 40 × 40 последовательный  | 73       | 0.001105  | 1.441e-01   | 1.491e-01   |
| 40 × 40 1 процесс         | 80       | 0.005571  | 1.327e-01   | 1.412e-01   |
| 40 × 40 2 процесса        | 80       | 0.005007  | 1.327e-01   | 1.412e-01   |     
| 40 × 40 4 процесса        | 80       | 0.003197  | 1.327e-01   | 1.412e-01   |  

Как и в случае OpenMP не получается наблюдать ускорение для использования MPI программы, так как накладные расходы значительно выше, чем потенциальный выигрыш.
Для версий MPI наблюдаем уменьшение времени работы, что говорит об эффективности нашего решения.
Ошибка (качество) решения - сопоставимая и немного лучше, чем у последовательного решения.


### 6.2 Запуски на больших сетках и графики ускорения

Таблица 2: MPI версии

| Кол-во процессов MPI | Число точек сетки (M×N) | Число итераций | Время, с | Ускорение, раз |
|---:|---:|---:|---:|---:|
| 1 | 400×600 | 730 | 7.82 | - |
| 2 | 400×600 | 730 | 3.89 | 2.01 |
| 4 | 400×600 | 730 | 2.01 | 3.89 |
| 8 | 400×600 | 730 | 1.09 | 7.17 |
| 16 | 400×600 | 730 | 0.75 | 10.43 |
| 1 | 800×1200 | 1048 | 46.49 | - |
| 4 | 800×1200 | 1048 | 11.49 | 4.05 |
| 8 | 800×1200 | 1048 | 5.82 | 7.99 |
| 16 | 800×1200 | 1048 | 3.20 | 14.53 |
| 32 | 800×1200 | 1048 | 4.22 | 11.02 |

#### Графики ускорения и времени выполнения

![Графики ускорения и времени выполнения MPI](results/speedup_graph_MPI.png)


Из графиков видно:
- **Ускорение** растет с увеличением числа процессов, достигая 14.53 раз на 16 процессах для сетки 800×1200
- Видно, что для сетки 800×1200 ускорение не монотонно на 32 процессах, это может быть связано с накладными расходами, которые возникают на бОльшем количестве процессов.
- Для сетки 800×1200 эффективность выше благодаря большему объему вычислений
- Ускорение во всех случаях оказывается меньше линейного 

## 7. Структура проекта

```
SuperComp/
├── src/
│   ├── poisson_sequential.cpp      # Последовательная реализация
│   ├── poisson_omp.cpp             # OpenMP реализация
│   └── plot_solution.py            # Визуализация (Python)
├── tests/
│   └── test_poisson.cpp            # Тесты корректности
├── results/
│   └── solution_40x40.txt          # Результаты расчета
├── Makefile                        # Сборка проекта
├── REPORT.md                       # Данный отчет
└── README.md                       # Общая информация
```
