# Инструкция по использованию программы

## Быстрый старт

```bash
# Компиляция
make

# Запуск
./poisson_sequential
```

## Что делает программа

Решает задачу Пуассона для области-сапожка (вариант 7):
- Область: квадрат `[-1, 1] × [-1, 1]` без правого верхнего квадранта `[0, 1] × [0, 1]`
- Уравнение: `-Δu = 1` в области D, `u = 0` на границе
- Метод: фиктивные области + разностная схема + метод сопряженных градиентов

## Результаты

Программа автоматически:
1. Решает задачу на трех сетках: 10×10, 20×20, 40×40
2. Выводит для каждой сетки:
   - Количество итераций
   - Время решения
   - Нормы решения (Евклидова и максимум)
3. Сохраняет решение на сетке 40×40 в файл `solution_40x40.txt`

## Пример вывода

```
=== Решение задачи Пуассона (вариант 7 - сапожок) ===
Область: {(x,y): -1<x,y<1} \ {(x,y): 0<x,y<1}

Сетка: 10 x 10
  Итераций: 21
  Время решения: 0.000019 с
  Норма ||w||_E: 1.497409e-01
  Норма ||w||_C: 1.512149e-01
```

## Формат выходного файла

`solution_40x40.txt` содержит три колонки:
```
x y u(x,y)
```

Каждая строка - координаты узла сетки и значение решения в этом узле.

## Архитектура кода

### Основные компоненты

1. **Геометрия** (строки 16-103):
   - `is_in_domain()` - проверка точки
   - `segment_length_in_D()` - длина отрезка в области
   - `cell_area_in_D()` - площадь ячейки в области

2. **Класс PoissonSolver** (строки 105-396):
   - Хранит параметры сетки и коэффициенты
   - Реализует оператор A и предобуславливатель D
   - Метод сопряженных градиентов

3. **Main** (строки 398-437):
   - Цикл по сеткам
   - Вывод результатов

### Как изменить область

Для другого варианта задания измените функцию `is_in_domain()`:

```cpp
// Пример: для круга радиуса 1
bool is_in_domain(double x, double y) {
    return (x*x + y*y < 1.0);
}
```

### Как изменить параметры

В функции `main()`:
- `grid_sizes` - размеры сеток
- `delta` - точность метода (по умолчанию 1e-6)
- `max_iter` - максимум итераций (по умолчанию 100000)

### Как изменить правую часть

В методе `compute_coefficients()` класса `PoissonSolver`:
```cpp
// Вместо F[i][j] = area_in_D / (h1 * h2);
// Используйте вашу функцию f(x, y)
F[i][j] = f(x, y) * area_in_D / (h1 * h2);
```

## Следующие шаги

После проверки последовательной версии:
1. Добавьте директивы OpenMP для параллелизации циклов
2. Реализуйте MPI-версию с разбиением области
3. Создайте гибридную MPI+OpenMP версию

## Отладка

Если программа не работает:
1. Проверьте компиляцию: `make clean && make`
2. Запустите на маленькой сетке: измените `grid_sizes = {{5, 5}}`
3. Увеличьте `delta` для быстрой сходимости
4. Проверьте, что область D не пустая: добавьте вывод в `is_in_domain()`
